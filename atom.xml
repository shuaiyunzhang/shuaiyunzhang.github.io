<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Nekonyan's秘密基地]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://nekonyan.me/"/>
  <updated>2015-07-15T14:26:10.000Z</updated>
  <id>https://nekonyan.me/</id>
  
  <author>
    <name><![CDATA[nekonyan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript设计模式学习总结]]></title>
    <link href="https://nekonyan.me/2015/07/15/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://nekonyan.me/2015/07/15/JavaScript设计模式学习总结/</id>
    <published>2015-07-15T14:24:27.000Z</published>
    <updated>2015-07-15T14:26:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript设计模式学习总结">JavaScript设计模式学习总结</h2><h3 id="前言">前言</h3><p>这段时间一直想写Blog主题，于是开始了准备工作，涉及到了模版引擎、MVC、设计模式的一些东西，于是想对近期学习做一个总结。本篇文章先来总结一下对于JavaScript设计模式的学习。</p>
<p>先来说一下对于设计模式的总体认识：<strong>设计模式是解决软件设计中常见问题的可复用方案</strong>，我认为这应该是设计模式最有价值的地方。从设计模式的发展来看，它是由某位土木工程师建筑设计原则的内容转变而来（果然是万法相通啊←_←），所以与其说它是具体某些编程语言的代码块，还不如说是一种思想或者解决问题的哲学。<br>而具体对应到软件设计中的设计模式，则不得不说四位作者出版的关于设计模式的书，这四个人称之为GoF（Gang of Four），他们在书中列举了23种面向对象设计中常用的经典设计模式，而本篇文章则重点对JavaScript中常用的设计模式来进行阐述。</p>
<h4 id="设计模式的好处">设计模式的好处</h4><ol>
<li>是已经验证的解决方案：为解决问题提供了可靠的方法，使用已经验证的解决方案。</li>
<li>很容易被复用：可以根据需求进行修改。</li>
<li>富有表达力：有相应的词汇和表述，易于沟通。</li>
</ol>
<h4 id="设计模式的几个要素">设计模式的几个要素</h4><ol>
<li>模式名称（pattern name）：每一个模式都有自己的名字，模式的名字使得我们可以讨论我们的设计。</li>
<li>问题（problem）：在面向对象的系统设计过程中反复出现的特定场合，它导致我们采用某个模式。</li>
<li>解决方案（solution）：上述问题的解决方案，其内容给出了设计的各个组成部分，它们之间的关系、职责划分和协作方式。</li>
<li>等等等～</li>
</ol>
<h4 id="23中设计模式分类">23中设计模式分类</h4><ul>
<li>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式与原型模式</li>
<li>结构型模式：适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式</li>
<li>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式</li>
</ul>
<h4 id="一些准备知识">一些准备知识</h4><ul>
<li><p>原型对象：创建的每一个新函数都会有一个prototype（原型）属性，它是一个指针，指向函数的原型对象，这个对象包含了可以由特定类型的所有实例共享的属性和方法，按照字面意思来理解prototype就是通过调用构造函数而创建的那个对象实例的原型对象。好处就是可以让所有对象实例共享它所包含的属性和方法。</p>
<p>所有原型对象会自动获得一个constructor（构造函数）属性（默认的，其他方法继承自Object），它同样是一个指针，指<br>向prototype属性所在的函数，比如有一个构造函数Person，那么Person.prototype.constructor指向Person，而Person.prototype指向Person prototype原型对象（好绕啊）􏱧􏰤􏰥。需要有一个图片（直接截Pro Js里面的图了）</p>
</li>
<li>原型链：这是Js中实现继承的主要方式，是利用原型让一个引用类型继承另一个引用类型的属性与方法，具体的表现就是让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针，假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。</li>
</ul>
<h3 id="JavaScript中常用设计模式">JavaScript中常用设计模式</h3><p>这里基本上是按照《JavaScript设计模式》一书的顺序来阐述，添加了少数其他的模式。</p>
<ul>
<li><p>Constructor（构造器）模式</p>
<p>这里的Constructor我的理解就是构造函数，具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>它有几个特点：</p>
<ul>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了this对象；</li>
<li>没有return语句</li>
</ul>
<p>但严格来说，这里应该是隐式做了一些工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">this</span> = &#123;&#125;;    <span class="comment">//隐式</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;    <span class="comment">//隐式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于创建了一个空对象并且<code>this</code>变量引用了该对象，属性和方法被加入到<code>this</code>引用的对象中，最后返回<code>this</code>（如果创建并返回一个新对象，比如说创建了一个that并返回，可能会与<code>this</code>返回的内容，比如<code>that.name</code>，发生冲突并覆盖<code>this</code>返回的冲突内容<code>this.name</code>），这里<code>this</code>显然是一个比较特殊的对象，指向了调用该函数的作用域（这个<code>this</code>很烦的，以后有时间写一篇关于它的）。</p>
<p>构造函数的问题，或者说构造器模式在Js中问题。那就是每个方法在每个实例上都要重新创建一遍，为什么呢？因为方法也是函数，相当于每个实例中的方法不是同一个函数的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.sayName === person2.sayName;    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Prototype（原型）模式</p>
<p>GoF中是说这是一种基于现有对象模版，通过克隆方式创建对象的模式（没看懂←_←）。对应到Js中可以理解为这是一种借助原型可以基于已有的对象创建新对象，同时还不必创建自定义类型。</p>
<p>在ES5中，真正的原型继承要求使用<code>Object.create</code>，这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name);    <span class="comment">// "Greg"</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.friends);    <span class="comment">// ["Shelby", "Court", "Van", "Rob"]</span></span><br></pre></td></tr></table></figure>
<p>在《JavaScript设计模式》一书中还对在不使用<code>Object.create</code>的情况下实现Prototype模式进行了讨论，这里就不细致阐述了，原书P72。</p>
<p>该模式的问题。因为包含引用类型值的属性（对象）始终都会共享相应的值，所以会出现一些问题。</p>
</li>
<li><p>Singleton（单例）模式</p>
<p>单例模式限制了类的实例化次数只能一次（嗯，还是看不懂←_←），在查看各类资料时，发现大概有两种单例的实现，一种最简单，就是<code>{}</code>，里面有各种属性或者方法。</p>
<p>另外一种则相对复杂。在该实例不存在的情况下，可以通过一个方法创建一个类来实现创建类的新实例；如果已经存在，则会返回该对象的引用。比如，需要在网页上建立一个遮罩层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createMask = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mask;    <span class="comment">//mask是单例的一个引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;    <span class="comment">//使用闭包使得mask是私有的</span></span><br><span class="line">        <span class="keyword">return</span> mask || (mask = <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>)));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Factory（工厂）模式</p>
<p>工厂就是把成员对象的创建工作转交给一个外部对象，可以消除对象之间的耦合，它分为简单工厂模式和抽象工厂模式，抽象工厂模式大致思路是先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法（<strong>其实这里最大的问题是Js是没有类这个概念，所以只能对比着理解了</strong>），这里就不做进一步阐述了。</p>
<p>对于简单工厂模式，举个例子：你有一个大的功能要做，其中有一部分是要考虑扩展性的，那么这部分代码就可以考虑抽象出来，当做一个全新的对象做处理。好处就是将来扩展的时候容易维护 - 只需要操作这个对象内部方法和属性，达到了动态实现的目的。示例－XHR工厂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> XMLHttpFactory = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;    <span class="comment">// 这是一个简单工厂模式</span></span><br><span class="line">XMLHttpFactory.createXMLHttp = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> XMLHttp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        XMLHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">        XMLHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> XMLHttp;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> AjaxHander = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;    <span class="comment">// XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。</span></span><br><span class="line">    <span class="keyword">var</span> XMLHttp = XMLHttpFactory.createXMLHttp();  </span><br><span class="line">    ...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Observer（观察者）模式</p>
<p>观察者模式的文字阐述看着头疼，但大致知道了平时常用的DOM事件算是观察者模式经常使用的场景。</p>
</li>
<li><p>Module（模块）模式</p>
<p>Module模式在某种程度上是基于对象字面量，将其作为一个作用域函数的返回值。它使用闭包封装“私有”状态和组织，只需要返回一个公有API，而其他一切则都维持在私有闭包中。该模式返回一个对象，类似于立即调用的函数表达式。Revealing Module（揭示模块）模式不做进一步阐述（由于只有书上讲到这个，我都不确定它到底是不是一种设计模式？）。</p>
<p>实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testModule = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        incrementCounter: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ++counter;</span><br><span class="line">        &#125;,</span><br><span class="line">        resetCounter: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"counter value prior to reset: "</span> + counter);</span><br><span class="line">            counter = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">testModule.incrementCounter();</span><br><span class="line">testModule.resetCounter();</span><br></pre></td></tr></table></figure>
<p>分析：代码的其他部分是无法直接读取incrementCounter()或resetCounter()，需要加模块前缀。counter变量实际上是与全局作用域隔绝的，因此表现的像一个私有变量，而<code>return</code>中返回的变量或者函数才是公有的。</p>
</li>
<li><p>Mediator（中介者）模式</p>
<p><em>待续</em></p>
</li>
<li><p>Facade（外观）模式</p>
<p>这个模式比较好理解，相当于提供了一个高层次的抽象接口，而对于底层的东西自己并不需要去关心，很经典的一个例子就是事件绑定的跨浏览器兼容解决方案，可以在最外层进行封装。再比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stopEvent = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;    <span class="comment">// 同时阻止冒泡和事件默认行为</span></span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法被封装为另外一个函数。</p>
</li>
<li><p>Decorator（装饰者）模式</p>
<p>对于该模式我的理解就是为对象添加新的功能（方法），貌似在其他语言中要实现这个功能会比较麻烦，但显然对于JS这门动态语言来说，这种添加功能不是随时都可以进行吗？看了资料的例子也和我想的差不多，直接往某个对象上赋一个函数值，简单粗暴，就不做阐述了。</p>
</li>
<li><p>Flyweight（享元）模式</p>
<p><em>待续</em></p>
</li>
<li><p>Bridge（桥接）模式</p>
<p><em>待续</em></p>
</li>
<li><p>Composite（组合）模式</p>
<p><em>待续</em></p>
</li>
<li><p>Adapter（适配器）模式</p>
<p><em>待续</em></p>
</li>
<li><p>Proxy（代理）模式</p>
<p><em>待续</em></p>
</li>
</ul>
<p>感觉以上这些就应该是JS中比较常用的一些设计模式，先写到这。其实严格来说，最先接触设计模式应该是买《JavaScript设计模式》这本书开始（两三个月前），当时完全是抱着一种只学设计模式的心态来学的，比较刻意，所以很多东西只是看了，但根本不懂，而最近开始接触的一些东西使我认识到其实设计模式自己无意中都接触过了一些，所以剩下的一些没写的设计模式我也不怎么着急，慢慢来。</p>
<h3 id="参考">参考</h3><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA</a>)</li>
<li><a href="http://book.douban.com/subject/24744217/" target="_blank" rel="external">《JavaScript设计模式》</a></li>
<li><a href="http://book.douban.com/subject/10546125/" target="_blank" rel="external">《JavaScript高级程序设计》</a></li>
<li><a href="http://blog.chinaunix.net/uid-26672038-id-3904513.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26672038-id-3904513.html</a></li>
<li><a href="http://developer.51cto.com/art/201109/288650_all.htm" target="_blank" rel="external">http://developer.51cto.com/art/201109/288650_all.htm</a></li>
<li><a href="http://blog.jobbole.com/29454/" target="_blank" rel="external">http://blog.jobbole.com/29454/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript设计模式学习总结">JavaScript设计模式学习总结</h2><h3 id="前言">前言</h3><p>这段时间一直想写Blog主题，于是开始了准备工作，涉及到了模版引擎、MVC、设计模式的一些东西，于是想对近期学习做一个总结。本篇文章先]]>
    </summary>
    
      <category term="FE" scheme="https://nekonyan.me/tags/FE/"/>
    
      <category term="JavaScript" scheme="https://nekonyan.me/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="https://nekonyan.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BFC的初步探索]]></title>
    <link href="https://nekonyan.me/2015/05/12/BFC%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/"/>
    <id>https://nekonyan.me/2015/05/12/BFC的初步探索/</id>
    <published>2015-05-12T15:12:10.000Z</published>
    <updated>2015-05-14T14:35:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1、因为一句话引起的疑问。">1、因为一句话引起的疑问。</h2><p>最近在温故《CSS权威指南》第三版时在“浮动与定位“那一章看到一句话：</p>
<blockquote>
<p>浮动元素会生成一个块级框，而不论这个元素本身是什么······它会像块级元素一样摆放和表现。对浮动元素声明<code>display: block</code>也不是不可能，不过没有必要这么做</p>
</blockquote>
<p>看到这句话，我产生了一个疑问，如果浮动元素生成了一个块级框的话，按照块级元素的特性，那么比如两个同级别的<code>div</code>在浮动以后也应该是另起一行的，也就是说浮动后和浮动前的表现没有区别。当然，在浏览器中实际的表现显然不是这样，而是更像<code>display: inline-block</code>的表现，为此我专门去找了<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements" target="_blank" rel="external">块级元素</a>的定义和<a href="http://www.w3.org/wiki/CSS/Properties/float" target="_blank" rel="external">浮动</a>的定义仔细看了看。虽然没有找到能够解释我上面疑惑的解答，但使我对于浮动有了更进一步的认识，在下一节姑且说一下，做一个记录。</p>
<p>最后我在阅读有关BFC的资料里面找到了可以解释上面问题的相关论述，算是解决了这个问题。</p>
<a id="more"></a>
<h2 id="2、对于浮动的进一步理解">2、对于浮动的进一步理解</h2><p>仔细想来，浮动这一概念应该是我当初学习CSS最难理解的概念之一，主要是元素浮动后会产生一些违反常识的效果，并不仅仅是元素浮动到哪一边就了事。</p>
<p>后来在逐渐的学习中，对于浮动我有了自己的一套理解：<strong>浮动会脱离正常的文档流，然后飘到比原来文档高一个层次的位置（在Z轴上），根据浮动属性值在父元素的范围限制下尽量往上（在Y轴上）靠边（在X轴上）飘，我会假想在正上方有一个光源，因此浮动后的元素在原来文档的位置会有一块阴影，原文档元素不能侵犯这块阴影区域，所以浮动后的元素还是会对文档产生影响。这里提一句就是绝对定位是从正常文档流删除，并且不会对文档其他部分产生影响，这个元素相当于不存在了，浮动还是基于正常的文档流</strong>，所以比如图片进行浮动后，文字会环绕这个图片。但后来我发现元素其实会进入我说的那块阴影区域，这个时候我就不理解了。比如说前面说的文字环绕，如果打开浏览器开发者工具，会发现<code>p</code>元素的范围其实已经进入了那块阴影区域，设置背景颜色就可以发现这一点。这说明我的理解有错吗？现在来看，大体上没错，但在一些细节上还是不够具体，导致理解有偏差。</p>
<p>在W3C的wiki上对于<code>float</code>的<a href="http://www.w3.org/wiki/CSS/Properties/float" target="_blank" rel="external">解释</a>是这样的：</p>
<blockquote>
<p><code>left</code> : The element generates a block box that is floated to the left. Content flows on the right side of the box, starting at the top.</p>
</blockquote>
<p>仔细品味这句话时，我明白了前面说的细节在哪里，“Content flows”，主语为Content，指的是其他元素的“内容”，而不是元素本身，比如说<code>p</code>元素，它本身是块级元素，所以元素本身范围会前后各占一行，但元素内容是文本，所以不会侵犯阴影区域，产生围绕效果。也就是说不会侵犯阴影区域的只是其他元素的内容（如果里面嵌套了其他元素也算是内容），而不是元素本身。</p>
<h2 id="3、BFC的定义">3、BFC的定义</h2><p>像很多网上介绍BFC一样，这里先介绍<strong>Box</strong>和<strong>Formatting Context</strong>的概念。</p>
<h3 id="Box:_CSS布局的基本单位">Box: CSS布局的基本单位</h3><p>具体W3C文档看<a href="http://www.w3.org/TR/CSS21/visuren.html" target="_blank" rel="external">这里</a><br>Box是CSS布局的对象和基本单位，直观点来说，就是一个页面是由很多个Box(即boxes)组成的。元素的类型和display属性，决定了这个Box的类型。不同类型的Box， 会参与不同的Formatting context(一个决定如何渲染文档的容器)，因此Box内的元素会以不同的方式渲染。常见的盒子类型</p>
<ol>
<li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li>
<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li>
</ol>
<h3 id="Formatting_context">Formatting context</h3><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<p>CSS3 中还增加了 GFC 和 FFC。</p>
<h3 id="BFC">BFC</h3><p><a href="http://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank" rel="external">W3C文档链接</a></p>
<p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h3 id="BFC的一些规则">BFC的一些规则</h3><ol>
<li>内部的Box会在垂直方向，从顶部开始一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box叠加。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。（这句话很重要！！！）</li>
<li>计算BFC的高度时，浮动元素也参与计算。</li>
</ol>
<h3 id="创建BFC的情况">创建BFC的情况</h3><ol>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的 float 不为 none)</li>
<li>绝对定位元素 (元素的 position 为 absolute 或 fixed)</li>
<li>内联块 inline-blocks (元素的 display: inline-block)</li>
<li>表格单元格 (元素的 display: table-cell，HTML表格单元格默认属性)</li>
<li>表格标题 (元素的 display: table-caption, HTML表格标题默认属性)</li>
<li>overflow 的值不为 visible的元素</li>
<li>弹性盒 flex boxes (元素的 display: flex 或 inline-flex)</li>
</ol>
<h3 id="我对于BFC的理解">我对于BFC的理解</h3><p>对于BFC我一直有一个疑问，那就是display 属性为 inline，会生成 inline-level box。并且参与IFC，而不是BFC，但创建BFC的一种情况明确就是元素的 display: inline-block，这不是自相矛盾吗？</p>
<p>意识到这个问题，在网上问了一些人，但解释的感觉不是很清楚，后来自己对照BFC的一些应用案例努力理解，有了一些自己的想法。</p>
<p>首先需要认识到的一点就是参与BFC和生成/创建/形成BFC的概念是不同的。正如前面所说的“只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。”这句话指的是只有block-level box才能参与BFC的创建，是一个前提条件。而创建BFC，是指创建一块渲染区域，这个区域里面包含了block-level box，这样理解的话就不会出现矛盾了。</p>
<p>在深入理解了BFC之后就可以对本文最开头的疑问做出一些解释了。</p>
<p>首先float之后，元素本身就创建了BFC，这点毋庸置疑，根据BFC的性质，这块区域就是一个隔离的独立容器了，两个float元素自然就会像display: inline-block一样进行表现了。那float生成的块级框呢？这就需要放到上一层来讨论，块级框肯定生成了Block-level box，这个Block-level box就只能参与上一层形成的BFC。一个很简单的例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"overflow: hidden;"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"float: left;background-color: red;"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"float: left;background-color: red;"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很明显，最外面的div也形成了一个BFC，里面又有两个BFC，所以能够防止塌陷，如果里面的div参与到上一层的BFC中是不是应该在垂直方向，从顶部开始一个接一个地放置呢？浏览器显然没有这么处理，在<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">MDN</a>上有这么一段话</p>
<blockquote>
<p>块格式化上下文包括了创建该上下文的元素的所有子元素，但不包括创建了新的块格式化上下文的子元素。</p>
</blockquote>
<p>这句话就解决了这个问题，对于上一层的BFC来说，里面两个div（创建了新的BFC）是不包括在内的，上面提到的问题也就无从谈起了。</p>
<p><strong>说到这里，我感觉有必要说一下最前面的那个疑问了，了解了这么多，我认为块级元素前后新起一行的显示效果会被BFC的显示效果所覆盖，也就是说BFC的优先级更高。</strong></p>
<h3 id="BFC的具体应用">BFC的具体应用</h3><p>这方面网络上有很多资料，大体上是三个：自适应两栏布局、清除内部浮动、防止垂直margin重叠（相邻的盒子可能是兄弟关系也可能是祖先关系，w3cplus那篇文章里面提到的clearance很有意思，值得一看，见下面链接）。</p>
<p>详细的代码也就不说了，网上的信息很全。<br>抛几个链接：</p>
<ul>
<li><a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a></li>
<li><a href="http://www.html-js.com/article/1866" target="_blank" rel="external">http://www.html-js.com/article/1866</a></li>
<li><a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html" target="_blank" rel="external">http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></li>
</ul>
<p>前面在写规则时，说第五点很重要是因为BFC内部的元素和外部的元素绝对不会互相影响，因此，当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1、因为一句话引起的疑问。">1、因为一句话引起的疑问。</h2><p>最近在温故《CSS权威指南》第三版时在“浮动与定位“那一章看到一句话：</p>
<blockquote>
<p>浮动元素会生成一个块级框，而不论这个元素本身是什么······它会像块级元素一样摆放和表现。对浮动元素声明<code>display: block</code>也不是不可能，不过没有必要这么做</p>
</blockquote>
<p>看到这句话，我产生了一个疑问，如果浮动元素生成了一个块级框的话，按照块级元素的特性，那么比如两个同级别的<code>div</code>在浮动以后也应该是另起一行的，也就是说浮动后和浮动前的表现没有区别。当然，在浏览器中实际的表现显然不是这样，而是更像<code>display: inline-block</code>的表现，为此我专门去找了<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements">块级元素</a>的定义和<a href="http://www.w3.org/wiki/CSS/Properties/float">浮动</a>的定义仔细看了看。虽然没有找到能够解释我上面疑惑的解答，但使我对于浮动有了更进一步的认识，在下一节姑且说一下，做一个记录。</p>
<p>最后我在阅读有关BFC的资料里面找到了可以解释上面问题的相关论述，算是解决了这个问题。</p>]]>
    
    </summary>
    
      <category term="BFC" scheme="https://nekonyan.me/tags/BFC/"/>
    
      <category term="CSS" scheme="https://nekonyan.me/tags/CSS/"/>
    
      <category term="FE" scheme="https://nekonyan.me/tags/FE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IFE任务2记录]]></title>
    <link href="https://nekonyan.me/2015/05/05/IFE%E4%BB%BB%E5%8A%A12%E8%AE%B0%E5%BD%95/"/>
    <id>https://nekonyan.me/2015/05/05/IFE任务2记录/</id>
    <published>2015-05-04T16:59:21.000Z</published>
    <updated>2015-05-04T17:05:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="任务二">任务二</h2><p>任务二<a href="https://github.com/baidu-ife/ife/tree/master/task/task0002" target="_blank" rel="external">地址</a></p>
<p>任务二主要是JS基础知识方面的训练，给出的参考资料链接有五个，两个慕课网的JS课程和W3CSchool教程均以看过，MDN有所了解但一直没怎么看，任务二促使我开始看MDN的JS部分。对于Codecademy也是有了解，点进去看之后，发现是主要是JS编程实践，这对于现阶段的我来说实在是很有帮助，马上就去注册了账号准备开始。</p>
<a id="more"></a>
<h3 id="Start">Start</h3><h3 id="1-_创建第一个页面交互">1. 创建第一个页面交互</h3><h4 id="1-1_任务描述">1.1 任务描述</h4><p>这部分没有什么难度。下面是一些我认为比较重要的点。</p>
<ul>
<li>在script元素里面做的代码修改使我很有启发，它将整个过程每一步具体要实现的功能都用函数封装起来，最后只有一个<code>initEvent()</code>接口，因为写代码比较少，虽然对这种思想有所了解，但没真正用过，值得注意。</li>
<li>页面效果在Chrome和IE8（无反应）下不同的原因很简单，因为IE8不支持<code>addEventListener</code>这个事件处理方法，应该是<code>attachEvent</code>，不过相信后面应该会讲到，在此不深究。</li>
</ul>
<h4 id="1-2_期望达成">1.2 期望达成</h4><ul>
<li>了解JavaScript是什么</li>
<li>如何在HTML页面加载JavaScript代码</li>
<li>搜索一下，为什么我们让你把<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>前。</li>
</ul>
<p>对于这三个问题之我的理解</p>
<ul>
<li>1、对于我来说，这是一个很大的问题，首先是一些认识，JS是一门Netscape推出的脚本语言，由ECMAScript、DOM和BOM三部分构成。看了MDN上的说法(见下面)，写的比较简单，在我的理解上应该还要加上<strong>弱类型</strong>、<strong>动态类型</strong>、<strong>基于原型</strong>这三点，在这个过程中了解到了<strong>“类型系统”</strong>这个概念，发现又是一个大坑啊，准备去研究一下。这样的话就可以用<strong>轻量级</strong>、<strong>解释型</strong>、<strong>面向对象</strong>、<strong>函数first-class</strong>加上上面说到的三个点来比较全面描述JavaScript这门语言。对于这七点中，<strong>弱类型</strong>、<strong>动态类型</strong>、<strong>函数first-class</strong>是我不熟悉的，但我进行了额外了解，但这里限于主题就不展开了。</li>
</ul>
<blockquote>
<p>JavaScript® (often shortened to JS) is a lightweight, interpreted, object-oriented language with first-class functions</p>
</blockquote>
<ul>
<li>2、想到的有两种，均使用<code>&lt;script&gt;</code>元素：1、从<code>src</code>属性导入外部js文件；2、在<code>&lt;script&gt;</code>元素内部嵌入js文件。当然按照1.3那篇文章的说法还有很多种。</li>
<li>3、这个问题在1.3给出链接中的那篇文章有详细的解释.</li>
</ul>
<blockquote>
<p>当浏览器解析到<code>&lt;script&gt;</code>标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，这意味着，其后的 styles.css 样式文件和<code>&lt;body&gt;</code>标签都无法被加载，由于<code>&lt;body&gt;</code>标签无法被加载，那么页面自然就无法渲染了。因此在该 JavaScript 代码完全执行完之前，页面都是一片空白。由于脚本会阻塞页面其他资源的下载，因此推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<body>标签的底部，以尽量减少对整个页面下载的影响。</body></p>
</blockquote>
<h3 id="2-_JavaScript数据类型及语言基础">2. JavaScript数据类型及语言基础</h3><h4 id="2-1_任务描述">2.1 任务描述</h4><ul>
<li><strong>1、判断数据类型。</strong>原本我使用的是<code>instanceof</code>操作符，在搜了一些信息后发现这种用法不是很好，具体见这篇<a href="http://segmentfault.com/a/1190000000730982" target="_blank" rel="external">文章</a>，里面介绍说为了判断数据类型，最好使用<code>Object.prototype.toString</code>方法，而不是<code>typeof</code>和<code>instanceof</code>，主要是因为该方法能够获取到对象内部属性[[Class]]的值，而另外两种则可能会返回一些不太标准的值，而且另外两种有自己专有的功能。</li>
<li><strong>2、深度克隆。</strong>以前没接触过，为此好好去找了些资料。首先需要对值类型和引用类型进行区别：</li>
</ul>
<blockquote>
<p>值类型：undefined,null,Boolean,String,Number。按照值来传递。</p>
<p>引用类型：对象、数组、函数。按址传递，引用类型在值传递的时候是内存中的地址</p>
<p>而对于克隆或者说拷贝分为两种：</p>
<p>浅度克隆：值类型为值传递，对象仍为引用传递。 </p>
<p>深度克隆：所有元素或属性均完全克隆，并于原引用类型完全独立，即，在后面修改对象的属性的时候，原对象不会被修改。</p>
</blockquote>
<ul>
<li><strong>3、数组去重。</strong>开始的想法是用两个<code>for</code>循环数组内部进行对比，然后判断再去重（大致思路见下面），但不是很喜欢这种方法。后面在浏览同学代码时发现使用<code>indexOf()</code>来进行去重，感觉很有意思，便决定使用这个来实现去重。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">            arr.splice(j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>4、字符串首尾去空格。</strong>这里使用了<code>if</code>判断，然后递归。这里需要注意的是js中全等的优先级大于逻辑或，我直接在全等后面直接用逻辑或导致浏览器报错说超出范围。使用正则本来是直接匹配<code>\s</code>的，但去看jQuery源码时发现是<code>rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g</code>，<code>\uFEFF\xA0</code>这两个东西实在不懂，去看<a href="http://www.zhihu.com/question/20129435" target="_blank" rel="external">知乎</a>、<a href="https://msdn.microsoft.com/library/2yfce773" target="_blank" rel="external">MSDN</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">MDN</a>上关于特殊字符的解释，似懂非懂，还是先加上再说。</li>
<li><strong>5、遍历数组。</strong>略过。</li>
<li><strong>6、获取第一层元素数量。</strong>略过。</li>
<li><strong>7、判断电子邮箱和手机号。</strong>常用的正则判断，总结一下：<code>/^([a-zA-Z0-9]+[_|\-|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\-|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]{2,3}$/</code>和<code>/^1[3|4|5|8][0-9]\d{4,8}$/</code></li>
</ul>
<h4 id="2-2_期望达成">2.2 期望达成</h4><ul>
<li>掌握JavaScript的各种数据类型概念、判断方法</li>
<li>掌握JavaScript函数、对象的概念</li>
<li>掌握字符串、数字、数组、日期等对象的方法</li>
<li>了解JavaScript的作用域</li>
<li>初步掌握正则表达式的写法</li>
</ul>
<p>对于这五个问题之我的理解</p>
<ul>
<li>1、略过</li>
<li>2、略过</li>
<li>3、个人认为这一点很重要，因为字符串、数字、数组的方法算是很常用的，像<code>splice()</code>、<code>slice()</code>这些，通过上面的练习和看资料，慢慢熟悉中。</li>
<li>4、这里应该指的是作用域链。关于这里，在《JavaScript高级程序设计》的4.2节说的很详细，不赘述。</li>
<li>5、略过。</li>
</ul>
<h3 id="3-_DOM">3. DOM</h3><h4 id="3-1_任务描述">3.1 任务描述</h4><ul>
<li><strong>1、添加样式。</strong>略过</li>
<li><strong>2、移除样式。</strong>略过</li>
<li><strong>3、判断是否同一父元素。</strong>略过</li>
<li><strong>4、相对于浏览器窗口位置。</strong>对于判断位置我一直搞不清楚，趁这个问题好好补了一下。判断元素位置在《JavaScript高级程序设计》一书中看到三种：<strong>偏移量（offset）</strong>、<strong>客户区大小（client）</strong>、<strong>滚动大小（scroll）</strong>。这三种具体都是在他们后面加上<strong>Height</strong>、<strong>Width</strong>、<strong>Left</strong>和<strong>Top</strong>。稍作延伸就是在鼠标事件中关于鼠标位置是另外三种<strong>Client</strong>、<strong>Screen</strong>和<strong>Page</strong>。而对于这个问题本身，浏览器窗口指的应该是视口，可以利用这个元素的<code>offsetLeft</code>和<code>offsetTop</code>与其<code>offsetParent</code>的相同属性相加，如此循环直至根元素。代码如下。不过后来又找到了一个新的方法<code>getBoundingClientRect()</code>，在<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">MDN</a>上的解释如下，更为简便，所以使用这种。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span><span class="params">(ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actualLeft = ele.offsetLeft;</span><br><span class="line">    <span class="keyword">var</span> current = ele.offsetParent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        actualLeft += current.offsetLeft;</span><br><span class="line">        current = current.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getElementTop方法实现类似</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The Element.getBoundingClientRect() method returns the size of an element and its position relative to the viewport.</p>
</blockquote>
<ul>
<li><strong>5、实现一个简单的Query。</strong>这个感觉自己实现的好繁琐。</li>
</ul>
<h3 id="4-_事件">4. 事件</h3><h4 id="4-1_任务描述">4.1 任务描述</h4><ul>
<li><strong>1、给元素绑定某个事件的响应。</strong>这个其实就是对事件处理程序的理解，注意兼容就是。</li>
<li><strong>2、移除响应。</strong>同上。</li>
<li><strong>3、实现对click事件的绑定。</strong>用上面的函数就行了。</li>
<li><strong>4、实现对于按Enter键时的事件绑定。</strong>注意enter的键值是13。</li>
<li><strong>5、事件代理。</strong>这个以前没接触过，去了解了一些资料。当我们需要对很多元素添加事件的时候，比如说<code>ul</code>元素里的<code>li</code>，一般会想到两种方法：直接给每个li添加onclick事件，还有就是给每个列表项调用监听，第一种方法比较简单直接，但是没有顾及到HTML与JavaScript的分离；后一种方法如果在增加监听之后，如果<code>ul</code>里面再添加一个<code>li</code>，则这个列表项没有被添加事件，也就是说事件无法绑定后加入的DOM节点。这时候就可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数（事件冒泡机制）。这就是事件代理。</li>
</ul>
<h3 id="5-_BOM">5. BOM</h3><h4 id="5-1_任务描述">5.1 任务描述</h4><ul>
<li><strong>1、判断IE浏览器。</strong>需要认识到的一点是：来自<code>navigator</code>对象的信息具有误导性。在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/navigator" target="_blank" rel="external">MDN</a>上很多属性都有一句：该值可能是不”正确”的。所以<code>navigator</code>不应该被用于检测浏览器版本。这是因为，<code>navigator</code>数据可被浏览器使用者更改，而且浏览器无法报告晚于浏览器发布的新操作系统。由于<code>navigator</code>可误导浏览器检测，使用对象检测可用来嗅探不同的浏览器。由于不同的浏览器支持不同的对象，您可以使用对象来检测浏览器。例如，由于只有Opera支持属性<code>window.opera</code>，您可以据此识别出Opera。本题我使用的是<code>ActiveXObject</code>。另外此题还需要判断版本号，这里就使用了<code>navigator.userAgent</code>。</li>
<li><strong>2、设置cookie。</strong>参看<a href="http://w3school.com.cn/js/js_cookies.asp" target="_blank" rel="external">w3cschool</a></li>
<li><strong>3、获取cookie。</strong>参看<a href="http://w3school.com.cn/js/js_cookies.asp" target="_blank" rel="external">w3cschool</a></li>
</ul>
<h3 id="6-_Ajax">6. Ajax</h3><h4 id="6-1_任务描述">6.1 任务描述</h4><ul>
<li><strong>1、尝试自己封装一个Ajax方法。</strong>自己接触Ajax不多，基本上这项任务是仿照着w3cschool来的。看了一下一些厉害的人的代码，感觉好细致，要多多学习。</li>
</ul>
<h3 id="练习部分（待更新）">练习部分（待更新）</h3><h4 id="练习1">练习1</h4><h4 id="练习2">练习2</h4><h4 id="练习3：轮播图">练习3：轮播图</h4><h4 id="练习4：输入提示框">练习4：输入提示框</h4><h4 id="练习5：界面拖拽交互">练习5：界面拖拽交互</h4>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="任务二">任务二</h2><p>任务二<a href="https://github.com/baidu-ife/ife/tree/master/task/task0002">地址</a></p>
<p>任务二主要是JS基础知识方面的训练，给出的参考资料链接有五个，两个慕课网的JS课程和W3CSchool教程均以看过，MDN有所了解但一直没怎么看，任务二促使我开始看MDN的JS部分。对于Codecademy也是有了解，点进去看之后，发现是主要是JS编程实践，这对于现阶段的我来说实在是很有帮助，马上就去注册了账号准备开始。</p>]]>
    
    </summary>
    
      <category term="FE" scheme="https://nekonyan.me/tags/FE/"/>
    
      <category term="IFE" scheme="https://nekonyan.me/tags/IFE/"/>
    
      <category term="JavaScript" scheme="https://nekonyan.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IFE任务1记录以及IFE]]></title>
    <link href="https://nekonyan.me/2015/05/05/IFE%E4%BB%BB%E5%8A%A11%E8%AE%B0%E5%BD%95%E4%BB%A5%E5%8F%8AIFE/"/>
    <id>https://nekonyan.me/2015/05/05/IFE任务1记录以及IFE/</id>
    <published>2015-05-04T16:59:10.000Z</published>
    <updated>2015-05-04T17:24:58.000Z</updated>
    <content type="html"><![CDATA[<p>差不多一个月前刷知乎时，看到百度的一位大牛在说招聘时提到了<a href="http://ife.baidu.com/" target="_blank" rel="external">IFE</a>，然后马上戳进去看，发现很适合自己目前的情况，然后在<a href="https://github.com/baidu-ife/ife" target="_blank" rel="external">GitHub</a>上报了名，很庆幸自己报上了，这是我<a href="https://github.com/shuaiyunzhang/ife" target="_blank" rel="external">仓库</a>的地址，进入群之后发现好多同年龄的大牛，好生佩服！也让自己充满了干劲！虽然自己正式接触前端时间的确有点迟，而且也不是科班出身，但正如一句话所说：</p>
<blockquote>
<p>做好一件事最好的时间是十年前，其次是现在。</p>
</blockquote>
<p>既然是自己选择了这条路，那就大胆地走下去吧。</p>
<a id="more"></a>
<p>在差不多一个多月的时间里，接触到了很多，感觉除了自己的学习外，跟进IFE更多是一种梳理，能多多少少了解现在正式的前端开发过程，毕竟是百度内部工程师出题和review。</p>
<p>今后会通过博客来记录我跟进IFE的任务过程中遇到的问题，如果是一些我认为比较重要的点，我会单独分出来写一篇文章做更详细的学习和记录。</p>
<h2 id="任务一">任务一</h2><p>任务一<a href="https://github.com/baidu-ife/ife/tree/master/task/task0001" target="_blank" rel="external">地址</a></p>
<p>我完成任务1的<a href="https://github.com/shuaiyunzhang/ife/tree/master/task/task0001/work/shuaiyunzhang" target="_blank" rel="external">地址</a></p>
<p><em>整理中</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>差不多一个月前刷知乎时，看到百度的一位大牛在说招聘时提到了<a href="http://ife.baidu.com/">IFE</a>，然后马上戳进去看，发现很适合自己目前的情况，然后在<a href="https://github.com/baidu-ife/ife">GitHub</a>上报了名，很庆幸自己报上了，这是我<a href="https://github.com/shuaiyunzhang/ife">仓库</a>的地址，进入群之后发现好多同年龄的大牛，好生佩服！也让自己充满了干劲！虽然自己正式接触前端时间的确有点迟，而且也不是科班出身，但正如一句话所说：</p>
<blockquote>
<p>做好一件事最好的时间是十年前，其次是现在。</p>
</blockquote>
<p>既然是自己选择了这条路，那就大胆地走下去吧。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="https://nekonyan.me/tags/CSS/"/>
    
      <category term="FE" scheme="https://nekonyan.me/tags/FE/"/>
    
      <category term="HTML" scheme="https://nekonyan.me/tags/HTML/"/>
    
      <category term="IFE" scheme="https://nekonyan.me/tags/IFE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于HTML5概念上的一些认识]]></title>
    <link href="https://nekonyan.me/2015/04/09/%E5%AF%B9%E4%BA%8EHTML5%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E8%AF%86/"/>
    <id>https://nekonyan.me/2015/04/09/对于HTML5概念上的一些认识/</id>
    <published>2015-04-09T04:03:47.000Z</published>
    <updated>2015-05-04T13:59:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="初识html5">初识html5</h2><h3 id="1、我与HTML5">1、我与HTML5</h3><p>对于前端来说，HTML5的开发是一个无法避开的领域，同时，整个前端开发也因为HTML5的成熟而充满活力。开始学习前端时，忙于学习基础知识，把HTML5当做新技术，只是浅尝辄止，束之高阁。不过到了现在这个时候，我有必要对HTML5开始一次比较系统的学习，这篇文章起一个头，从我的视角从一个概要的层面来说一些对于HTML5的认识。</p>
<h3 id="2、究竟什么是html5？">2、究竟什么是html5？</h3><p>认识一个新事物（虽然算起来html5也不小了。。。）首先需要搞清楚它的定义，最常用的方式应该就是把关键词丢到搜索引擎去搜，很多相关网站给出的解释是：</p>
<blockquote>
<p>“HTML5 是下一代的 HTML”</p>
</blockquote>
<a id="more"></a>
<p>虽然初看上去很简洁明了，但对于我来说，当初可是造成了很大的困扰。因为HTML长期给人的一种印象是简单的标记语言，连编程语言都算不上，但现实中遇到的一些实际应用比如离线存储啥的明显就不应该是传统html的内容啊。直到看到MDN的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5" target="_blank" rel="external">一篇文章</a>才理清了我的思绪，给了我一个全面的html5认识。那就是这句话：</p>
<blockquote>
<p>HTML5 is the latest evolution of the standard that defines HTML. The term represents two different concepts:<br>1、It is a new version of the language HTML, with new elements, attributes, and behaviors,<br>2、and a larger set of <strong>technologies</strong> that allows more diverse and powerful Web sites and applications. This set is sometimes called HTML5 &amp; friendsand often shortened to just HTML5.</p>
</blockquote>
<p>我的理解为HTML5是HTML这门语言最新演进版，但它涵盖两个方面，其一就是传统意义上的HTML语言版本演进，这是我以前对于html5的认识，比如增加了新的语义元素等，其二也是最重要的一方面，一系列的新兴web技术也被归到HTML5里面，在看《JavaScript高级程序设计》这本书时，我了解到这里面新兴的技术很多是一些新的JS API和规范。换句话说，HTML5极大的不同于以前的HTML，关于JS涉及了很多。</p>
<p>总的一句话就是，HTML5不仅仅是HTML版本的迭代，更是一系列新技术规范。</p>
<p>我对于html5的学习也将大致从这两个方向出发，不过很明显，技术规范这一部分的内容会很多。</p>
<h4 id="2-1、逸事——HTML5还是HTML_5？">2.1、逸事——HTML5还是HTML 5？</h4><p>最初接触时，真没有发现这两者有什么不同，以为只是印刷或者一种书写习惯罢了。有意思的事，后来发现这两者还是有很细微的区别的。</p>
<p>众所周知，一些浏览器厂商不满W3C，于是成立了WHATWG，初期这个组织算是推进HTML5标准制定的主要动力，在认识到新标准大势所趋之后，W3C基于WHATWG的成果推进新标准，但名字变成了HTML 5，多了一个空格。</p>
<p>来源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/Introduction_to_HTML5" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/Introduction_to_HTML5</a></p>
<h3 id="3、html5的具体内容">3、html5的具体内容</h3><p>要学习html5，需要对html5 的具体内容有一个了解，做到心中有数，由于2014年10月份，W3C正式发布了HTML5的正式推荐标准，相当于html5定稿，因此最全面的内容概述，莫过于W3C的<a href="http://www.w3.org/TR/html5/" target="_blank" rel="external">HTML5推荐标准</a>了</p>
<h4 id="3-1、对于W3C文档成熟过程的简单理解">3.1、对于W3C文档成熟过程的简单理解</h4><p>关于这部分内容可以直接戳 <a href="http://www.w3.org/2014/Process-20140801/#reports" target="_blank" rel="external">http://www.w3.org/2014/Process-20140801/#reports</a> 但这里面的东西实在太多了，只要掌握了解过程即可，在查询了一些资料后我进行了简化。</p>
<p>按照W3C的过程文档，一个推荐标准的发展需要通过不同的成熟级别。</p>
<p>来源：<a href="http://zh.wikipedia.org/wiki/W3C%E6%8E%A8%E8%8D%90%E6%A0%87%E5%87%86" target="_blank" rel="external">http://zh.wikipedia.org/wiki/W3C%E6%8E%A8%E8%8D%90%E6%A0%87%E5%87%86</a></p>
<ol>
<li><p>工作草案（WD）——Working Drafts<br>工作草案文档是一个标准的首次公开发表，在这一阶段，标准文档很可能会发生重大的修改</p>
</li>
<li><p>候选推荐标准（CR）——Candidate Recommendations<br>候选推荐标准与工作草案相比更加稳定，标准文档还可能发生进一步的修改，但此时重大的特性大部分已经锁定</p>
</li>
<li><p>提案（建议）推荐标准（PR）——Proposed Recommendations<br>在这一阶段，标准文档已经提交到W3C顾问委员会进行最后的批准，这一阶段很少导致对标准的任何重要的修改</p>
</li>
<li><p>W3C推荐标准（REC）——Recommendations<br>最成熟的发展阶段，可以广泛应用</p>
</li>
<li><p>后续的修订<br>推荐标准通过分别发布的勘误表来更新，当积累到足够的实质上的修订，会发布推荐标准的一个新版本</p>
</li>
</ol>
<p>附一张<a href="http://www.infoq.com/cn/news/2012/03/w3c-adviser-on-HTML5" target="_blank" rel="external">InfoQ</a>上找到的图，图中用实线和虚线分别画出了工作流程，而且多了一个最终工作草案，不过和前文的文字描述也大同小异，另外这篇文章也蛮值得一看的，虽然时间有点久了。<br><img src="http://7vzok8.com1.z0.glb.clouddn.com/w3c process zh.jpg" alt="w3c process"></p>
<h4 id="3-2、HTML5中的新语义标签">3.2、HTML5中的新语义标签</h4><p><em>待更新</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="初识html5">初识html5</h2><h3 id="1、我与HTML5">1、我与HTML5</h3><p>对于前端来说，HTML5的开发是一个无法避开的领域，同时，整个前端开发也因为HTML5的成熟而充满活力。开始学习前端时，忙于学习基础知识，把HTML5当做新技术，只是浅尝辄止，束之高阁。不过到了现在这个时候，我有必要对HTML5开始一次比较系统的学习，这篇文章起一个头，从我的视角从一个概要的层面来说一些对于HTML5的认识。</p>
<h3 id="2、究竟什么是html5？">2、究竟什么是html5？</h3><p>认识一个新事物（虽然算起来html5也不小了。。。）首先需要搞清楚它的定义，最常用的方式应该就是把关键词丢到搜索引擎去搜，很多相关网站给出的解释是：</p>
<blockquote>
<p>“HTML5 是下一代的 HTML”</p>
</blockquote>]]>
    
    </summary>
    
      <category term="FE" scheme="https://nekonyan.me/tags/FE/"/>
    
      <category term="HTML5" scheme="https://nekonyan.me/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网站http改为https方法的初步探索]]></title>
    <link href="https://nekonyan.me/2015/04/06/%E7%BD%91%E7%AB%99http%E6%94%B9%E4%B8%BAhttps%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/"/>
    <id>https://nekonyan.me/2015/04/06/网站http改为https方法的初步探索/</id>
    <published>2015-04-06T13:33:11.000Z</published>
    <updated>2015-04-06T15:30:05.000Z</updated>
    <content type="html"><![CDATA[<p>这一两年来，信息安全越来越受关注，前不久百度也宣布全站https（不过在网上查到一些消息说，以前百度对https貌似不是很友好），https使得网络上的通讯变得更为安全，当然，没有完美的事物，https也存在被劫持的问题，此外，谷歌曾经也发布公告说会对采用https的网站优先排名。总的来说，使用https是大势所趋。</p>
<p>作为一个关注前沿信息技术的伪极客，我开始关注起https来，了解了很多关于https技术的信息，也琢磨着能不能将我的博客访问从http改为https，为此，我开始在网上疯狂找东西，最终的结果还是有的，只是让人很不满意，最后的结果是如果直接在URL上直接输入<a href="https://nekonyan.me" target="_blank" rel="external">https://nekonyan.me</a> ，就会发现：</p>
<a id="more"></a>
<ol>
<li><p>会出现内容，至少说明ssl certificate是可用的（一般的网站直接将url改为https是找不到网页的），只不过样式并没有加载（可能是mixed content中链接的原因，但不确定）</p>
</li>
<li><p>点击其中的链接，根据浏览器的提示，链接全部变为<a href="https://nekonyan.me/xxx" target="_blank" rel="external">https://nekonyan.me/xxx</a> ，但点击进去，全部没内容，但如果你在此时的URL上加上一个正斜杠，内容又有了，当然还是没有样式（可能是网页代码托管服务器的处理URL问题，但不确定）</p>
</li>
<li><p>第2点的解决方法并不是万无一失，点击任意一个具体的标签就会发现就算在URL的最后加上正斜杠也是没有内容的（这个想不到可能的原因）</p>
</li>
<li><p>当然，文章和RSS的链接是直接可以点击的，不需要加斜杠（从浏览器提示来说这些链接最后）</p>
</li>
<li><p>使用https，网页加载变得极为缓慢，不过这个原因好猜，应该使用了国外cloudflare的缘故</p>
</li>
<li><p>https页面刷新就显示不了内容了，这是最让我受不了的一点，按照理论来说，https和http网站直观的使用感受是一样的，http怎样表现，https也怎么表现，可我这里事与愿违（想不到原因）</p>
</li>
<li><p>最后一点是使用https后，我chrome（目前最新版）能够显示，但FireFox、Safari还有虚拟机中的IE11无法打开，国内一众浏览器貌似也能打开，虽然cloudflare官方回复是说有浏览器和操作系统限制（链接），但我这里又不是老掉牙的浏览器和操作系统，按理来说不会出现问题呀（无法确定原因）</p>
</li>
</ol>
<p>很幸运的是如果是通过http来访问还是很流畅，并没有影响什么。你可能会问现在改URL为什么也是显示找不到内容，具体原因在第五部分第二小点进行阐述。虽然效果并不是很好，但我还是想把我的过程写出来，毕竟只是初步探索，如果谁发现了有更好的方法请一定告诉我！！！</p>
<h2 id="一、什么是HTTPS">一、什么是HTTPS</h2><p>https是http运行在SSL之上（over），SSL运行在TCP之上（over），我的理解就是https比http多了一层协议进行加密，不过也不能简单的理解为https＝http＋ssl，因为毕竟https是应用层协议（默认端口为443），只能理解为https的构成结构为http＋ssl，相应的因为多了一层加密协议，会花费更多的时间。</p>
<p>https最核心的应该是ssl证书，通过该证书浏览器可以验证网站的身份，保证和网站信息传递的安全性，也可以防止信息泄漏被偷听。</p>
<p>采用https后，最明显的就是URL前会出现一个锁型小图标，具体什么样子分情况。以下是几种情况：</p>
<ol>
<li><p><img src="http://7vzok8.com1.z0.glb.clouddn.com/EVhttps.png" alt="EVhttps"><br>EV SSL（扩展验证型）证书，颁发机构（CA）颁发前会进行更严格的身份审核，并在证书信息中写明组织机构等信息，以此提高证书对用户的可信度。</p>
</li>
<li><p><img src="http://7vzok8.com1.z0.glb.clouddn.com/normalhttps.png" alt="normalhttps">普通的SSL证书，只针对域名，不提供详细的所属组织机构信息。</p>
</li>
<li><p><img src="http://7vzok8.com1.z0.glb.clouddn.com/mixedhttps.png" alt="mixedhttps">页面中调用了非安全传输的资源（不是https开头），如外链图片或JS文件（mixed content），它们有可能在网络传输中被第三方截取、篡改，从而可能危及整个页面的安全性。</p>
</li>
</ol>
<p>从这里看出ssl证书的权威性是保证https通信安全的关键，而保证ssl证书权威性的机构就是颁发证书的CA，我想这也许就是权威性高的ssl证书价格高的原因吧，毕竟单纯从数学算法角度来说，生成证书是很容易的，在一些服务器环境就是几个命令的问题，但这种证书对于那些对安全敏感的公司机构肯定是不够的，购买权威CA颁发的证书更安全，这些证书也得到了个大浏览器厂商的认证。下面这张图最能说明各个组成的关系：<br><img src="http://7vzok8.com1.z0.glb.clouddn.com/https.png" alt="https"></p>
<h2 id="二、一般情况改为HTTPS的方法">二、一般情况改为HTTPS的方法</h2><p>这里指的是服务器环境或者可以操作服务器环境的网站的改为https方法，由于我的博客只是静态资源托管在gitcafe，所以对于这一点，我并没有仔细去研究。不过从看的资料来说，过程大致是购买具有公信力的证书，对服务器进行配置，基本不关客户端的事，如果感觉那些高大上机构的证书贵，可以去买便宜的，甚至是免费的ssl证书，不过各种风险肯定是有的。</p>
<h2 id="三、网站是否有必要改为HTTPS">三、网站是否有必要改为HTTPS</h2><p>关于这个问题其实也很简单，看需求，脱离了实际情况来讨论问题就是耍流氓！对于重视用户安全隐私的网站使用https还是很有必要的，比如说银行（虽然国内还比较少），在线支付平台（支付宝），等等，另外新兴的技术论坛社区也蛮喜欢用https的，可能里面用户隐私、和谐的东西比较多吧。。。，而向新闻、视频网站相对来说，https就不是那么重要了，同理，其实个人博客也不是那么需要，我仅仅是探索性质的尝试。我分享一篇外国人的博客：<a href="http://nickcraver.com/blog/2013/04/23/stackoverflow-com-the-road-to-ssl/" target="_blank" rel="external">Stackoverflow.com: the road to SSL</a>，里面以StackOverflow为例，对采用HTTPS进行了讨论，有启发价值。</p>
<h2 id="四、不同ssl服务的选择">四、不同ssl服务的选择</h2><p>前面说过ssl证书很重要，因此这里主要ssl服务主要是指CA的选择，高大上的有verisign、globalsign，特别是verisign在银行业务方面应用广泛，不过，个人的使用没必要用到这些（也用不起。。。），所以这里讲的主要是相对实惠甚至免费的ssl证书，我了解到的主要实惠的有PositiveSSL/EssentialSSL/RapidSSL三种，</p>
<ol>
<li>PositiveSSL 是 GeoTrust 的低端品牌 </li>
<li>EssentialSSL 是 Comodo 的</li>
<li>RapidSSL 是 Twate 的</li>
</ol>
<p>GeoTrust、Twate、Comodo三者均是较早的SSL数字签名服务商, 被信任比率彼此相当，作为他们的中间证书，受信任的比率与根证书基本上一致的。GeoTrust 和 Twate 均被 Verisign 收购，并入了 现在的Symantec公司。</p>
<p>虽然说是相对实惠，但每年也是几百块钱RMB啊，作为学生党，感觉划不来，最重要的是他们貌似都需要网站服务器支持ssl，我的博客原来是托管在github pages上的，现在转到了gitcafe pages，仅仅只是一个托管平台，根本不可能对服务器进行操作，另外我抱着尝试着的心态去了解了Github Pages的信息，发现它是不支持https的，在Gitcafe上询问工作人员结果也是不支持，所以基本上断了这条路。而免费的ssl证书像startssl，还有域名注册机构赠送的ssl证书也是差不多的问题，而且像startssl这些还时不时被Q掉，情况真的很糟糕。</p>
<p>我意识到我必须通过一个中介来实现https，通过询问网上认识一些牛人，别人很随意的指点了cloudflare这条路，使用它的Flexible SSL Mode，这可忙坏我了，因为这完全是新东西，以前要研究东西，网上很多人已经做了，有了大量的资料还是中文，但这次不同，很少有人通过这种方法为托管平台实现HTTPS，有资料还是简单的英文资料，遇到了问题只能看官方介绍文档和社区的解答，虽然过程比较苦逼，但我发现这条路是可行的，我了解到ssl证书是和网站IP绑定的，也就是ssl证书与网站一一对应，但cloudflare并没有给每个使用它们服务的用户分配ssl证书，它的证书貌似是Comodo的，原理是用户访问网站时会经过他们的服务器来实现https，<a href="https://blog.cloudflare.com/introducing-universal-ssl/" target="_blank" rel="external">具体介绍</a>，下面是他们提供的三种模式：<br><img src="http://7vzok8.com1.z0.glb.clouddn.com/ssl.png" alt="CF SSL Mode"></p>
<p>理解是服务器没开ssl就选择第一种（Flexible），如果你是自签的证书就选第二种（Full），你买了证书就选第三种（Full strict）。很明显，我这种情况只适合Flexible Mode，不过就像给我指导的那个人所说，这个只是看起来实现了https，的确，这种方法并没有全程使用ssl，只是在用户和cloudflare那一段使用了ssl，不过对于我探索来说，已经够了。另外cloudflare会在2015年进入国内，所以不用担心被Q的问题了。</p>
<h2 id="五、个人博客改为https的方法">五、个人博客改为https的方法</h2><ol>
<li>注册cloudflare账号。</li>
</ol>
<p>按照指示，注册账号，它会有几个步骤，在其中的一步她会给出两个nameserver地址。</p>
<ol>
<li>修改nameserver。</li>
</ol>
<p>它会要求你去当初域名注册的机构修改nameserver地址，拿我自己作比方，我是在godaddy注册域名的(如果实在不知道可以使用whois来查询)，是用DNSpod做dns解析，当初需要将godaddy的nameserver改为dnspod提供的nameserver，现在需要将那个nameserver改为cloudflare提供的nameserver，当然很多人不愿意修改，在V2EX上看到一种解决办法那就是将nameserver改为CF的后，等到显示https可用（将URL改为https，不断刷新，显示出页面就说明已激活，官方说时间是最多24小时，但我的激活时间应该是十多分钟），就将nameserver改回来，再在提供dns解析网站设置一条A或者NS记录，指向CloudFlare提供的某个nameserver地址。这可行吗？结论是不可行，所以现在我的博客无法通过https访问，CF的官方回答大意是它会隔一段时间检测nameserver值，发现改动则不提供ssl服务。那为什么不就用CF的nameserver呢？原因同样简单：慢！</p>
<ol>
<li>修改Page Rules</li>
</ol>
<p>激活后，进入dashboard，点击设置，弹出的选项中会有一个page rules，点击进入page rules页面，这个页面关键有几点，一是需要写pattern，pattern的意思是下面各种规则的匹配对象，直接写域名就行，也可以加上http:// 或者www子域名，另外可以使用*来匹配，如<a href="http://nekonyan.me" target="_blank" rel="external">http://nekonyan.me</a> ；二是要想一直使用https，请选择always uses https，这样整个网站都会使用https，如果不这样就会在网站中点击站内链接时又变为http；三就是在下面的SSL规则中选择Flexible SSL，千万别选错，不然也会没法访问。最后就是add rule了。一般过个几分钟，规则就会生效。其他规则可自行摸索。</p>
<p>如果还有什么问题的话，可以去CloudFlare的<a href="https://support.cloudflare.com/hc/en-us" target="_blank" rel="external">支持板块</a>寻找帮助</p>
<p>参考资料：<br>1、<a href="https://www.benburwell.com/posts/configuring-cloudflare-universal-ssl/" target="_blank" rel="external">https://www.benburwell.com/posts/configuring-cloudflare-universal-ssl/</a></p>
<p>2、<a href="https://icloud.net/blog/86/how-to-enable-ssl-conection-with-cloudflare-for-free-plan-users/" target="_blank" rel="external">https://icloud.net/blog/86/how-to-enable-ssl-conection-with-cloudflare-for-free-plan-users/</a></p>
<p>3、<a href="https://support.cloudflare.com/hc/en-us/articles/200168306-Is-there-a-tutorial-for-Page-Rules-" target="_blank" rel="external">https://support.cloudflare.com/hc/en-us/articles/200168306-Is-there-a-tutorial-for-Page-Rules-</a></p>
<h2 id="六、总结">六、总结</h2><p>总的来说，我通过CloudFlare的Flexible SSL Mode实现了https，但效果不是很理想，而且最后因为被CF检测到nameserver变动的原因导致SSL服务被禁用。而对于Flexible SSL Mode本身而言，其实算不得上真正的https，毕竟只有一段进行了SSL加密，不过这次探索还是很有意义的，使我对http改为https的方法过程有了一个粗浅的了解。日后有时间的话，肯定会对这一块重新进行探索，解决当初遇到的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一两年来，信息安全越来越受关注，前不久百度也宣布全站https（不过在网上查到一些消息说，以前百度对https貌似不是很友好），https使得网络上的通讯变得更为安全，当然，没有完美的事物，https也存在被劫持的问题，此外，谷歌曾经也发布公告说会对采用https的网站优先排名。总的来说，使用https是大势所趋。</p>
<p>作为一个关注前沿信息技术的伪极客，我开始关注起https来，了解了很多关于https技术的信息，也琢磨着能不能将我的博客访问从http改为https，为此，我开始在网上疯狂找东西，最终的结果还是有的，只是让人很不满意，最后的结果是如果直接在URL上直接输入<a href="https://nekonyan.me">https://nekonyan.me</a> ，就会发现：</p>]]>
    
    </summary>
    
      <category term="CloudFlare" scheme="https://nekonyan.me/tags/CloudFlare/"/>
    
      <category term="HTTPS" scheme="https://nekonyan.me/tags/HTTPS/"/>
    
      <category term="SSL" scheme="https://nekonyan.me/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客从GitHub迁移到GitCafe的记录]]></title>
    <link href="https://nekonyan.me/2015/03/27/%E5%8D%9A%E5%AE%A2%E4%BB%8EGitHub%E8%BF%81%E7%A7%BB%E5%88%B0GitCafe%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>https://nekonyan.me/2015/03/27/博客从GitHub迁移到GitCafe的记录/</id>
    <published>2015-03-27T09:32:05.000Z</published>
    <updated>2015-03-27T14:11:43.000Z</updated>
    <content type="html"><![CDATA[<p>有时候GitHub的确很难打开（就比如今天下午一些时候），相应的托管在上面的博客访问速度也受到了影响。以前看到过别人将博客托管在GitCafe上，当时的访问速度让我眼前一亮，十分流畅。因此，时隔这么久之后，我决定将Hexo博客迁移到GitCafe上，也算是做个备份。本篇文章主要是对托管在GitHub上的Hexo博客迁移到GitCafe过程的记录，也算是我开始认真写博客的开始。</p>
<h2 id="准备工作">准备工作</h2><ol>
<li><p>首先需要注册一个<a href="https://gitcafe.com" target="_blank" rel="external">GitCafe</a>账号，GitCafe的操作习惯和GitHub很相似，熟悉GitHub的上手比较快。</p>
</li>
<li><p>注册完成之后，前往<em>SSH公钥管理</em>添加SSH公钥，这里我直接使用GitHub的.pub文件密钥</p>
</li>
</ol>
<a id="more"></a>
<h2 id="在GitCafe上新建一个博客项目">在GitCafe上新建一个博客项目</h2><p>新建过程其实和GitHub也差不多，<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki" target="_blank" rel="external">这里</a>是官网的教程。具体来说就是，创建一个与用户名(如果是组织，就是组织名)相同名称的项目。如果你创建的项目名与用户名相同，GitCafe会自动识别成这是一个Page项目。</p>
<h2 id="创建gitcafe-pages分支（branch）">创建gitcafe-pages分支（branch）</h2><p>进入到博客目录下面的“.deploy-git”目录下，注意这个目录默认是隐藏的。使用以下命令创建该分支，并切换到该分支，通俗理解该分支其实就是一个文件夹。<br><code>git checkout -b gitcafe-pages</code></p>
<h2 id="添加到gitcafe的远程仓库">添加到gitcafe的远程仓库</h2><p>在该分支目录下执行该命令：<br><code>git remote add origin &#39;git@gitcafe.com:yourname/yourname.git&#39;</code></p>
<p>将yourname替换为你的GitCafe用户名即可。</p>
<h2 id="最后push到gitcafe仓库">最后push到gitcafe仓库</h2><p>同样是在该分支目录下执行该命令：<br><code>git push -u origin gitcafe-pages</code></p>
<p>以后使用<code>hexo g</code>生成静态文件之后到“.deploy-git”目录下执行该命令即可。</p>
<h2 id="绑定域名">绑定域名</h2><p>进入项目管理界面，点击自定义域名，再次参见<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki" target="_blank" rel="external">官方教程</a>，在在域名管理界面（我的是DNSPod）添加一个CNAME记录时，如果出现无法再添加CNAME的情况，可以添加一个A记录，值为207.226.141.135（应该是gitcafe服务器的地址）。</p>
<h2 id="修改”_config-yml”">修改”_config.yml”</h2><p>想要直接使用<code>hexo d</code>提交到GitCafe需要修改博客目录下的“_config.yml”，格式如下：</p>
<pre><code><span class="attribute">deploy</span>:
  <span class="attribute">type</span>: git
  <span class="attribute">repository</span>: git<span class="variable">@gitcafe</span>.<span class="attribute">com</span>:yourname/yourname.git
  <span class="attribute">branch</span>: gitcafe-pages
</code></pre><h2 id="问题">问题</h2><p>在deploy时遇到了一个问题，显示为<code>error: failed to push some refs to &#39;git@gitcafe.com:shuaiyunzhang/shuaiyunzhang.git&#39;</code>，解决方法为将.deploy-git文件夹删除（在Mac中用命令行删除更为方便）再重新尝试即可。</p>
<h2 id="其他">其他</h2><p>如果想再同步到GitHub只需要切换分支即可，进入到“.deploy-git”目录执行以下命令，切换git工作分支为master：<br><code>git checkout master</code></p>
<p>然后就直接像之前使用hexo一样即可,<code>hexo d</code>可以直接提交到github。如果再想提交到gitcafe直接再切换回gitcafe-pages分支即可。可以使用以下命令查看当前工作分支：<br><code>git branch</code><br>不过在网上找资料时貌似还可以同时同步两个，这点暂时放下，以后有时间再去研究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时候GitHub的确很难打开（就比如今天下午一些时候），相应的托管在上面的博客访问速度也受到了影响。以前看到过别人将博客托管在GitCafe上，当时的访问速度让我眼前一亮，十分流畅。因此，时隔这么久之后，我决定将Hexo博客迁移到GitCafe上，也算是做个备份。本篇文章主要是对托管在GitHub上的Hexo博客迁移到GitCafe过程的记录，也算是我开始认真写博客的开始。</p>
<h2 id="准备工作">准备工作</h2><ol>
<li><p>首先需要注册一个<a href="https://gitcafe.com">GitCafe</a>账号，GitCafe的操作习惯和GitHub很相似，熟悉GitHub的上手比较快。</p>
</li>
<li><p>注册完成之后，前往<em>SSH公钥管理</em>添加SSH公钥，这里我直接使用GitHub的.pub文件密钥</p>
</li>
</ol>]]>
    
    </summary>
    
      <category term="GitCafe" scheme="https://nekonyan.me/tags/GitCafe/"/>
    
      <category term="GitHub" scheme="https://nekonyan.me/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo博客搭建二三事]]></title>
    <link href="https://nekonyan.me/2015/02/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://nekonyan.me/2015/02/17/Hexo博客搭建二三事/</id>
    <published>2015-02-17T03:03:38.000Z</published>
    <updated>2015-02-17T11:51:32.000Z</updated>
    <content type="html"><![CDATA[<p>一直想做些好玩的事了，比如说做个个人网站啥的（虽然做个网站是基础中的基础，没多大技术含量……汗颜），在看到同学捣腾的<a href="http://www.jellybool.com/" target="_blank" rel="external">作品</a>后，心向往之，但由于本人拖延症已到晚期，五月病时不时还要发作一下，迟迟未开始，在深刻认识到技术需要实践这个道理之后，终于动工啦！用《舰队collection》里面的话来说就是“不要怂，单纵就是干”！</p>
<p>这篇文章主要是对博客搭建过程做个记录，但不会很详细的讲述。以下分为三个方面来做阐述：采用的工具、搭建流程以及遇到的问题。如果这些浅薄的文字能够帮助到遇到同样问题的有缘人，那是我的荣幸。</p>
<h2 id="采用的工具">采用的工具</h2><ol>
<li><a href="http://hexo.io/" target="_blank" rel="external">Hexo</a></li>
<li><a href="https://github.com/" target="_blank" rel="external">Github Pages</a></li>
<li><a href="http://msysgit.github.io/" target="_blank" rel="external">Git</a>或者<a href="https://windows.github.com/" target="_blank" rel="external">Github for Windows</a></li>
<li><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://duoshuo.com/" target="_blank" rel="external">多说</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Next Theme</a></li>
<li><a href="http://www.qiniu.com/" target="_blank" rel="external">七牛</a></li>
<li><a href="http://www.sublimetext.com/" target="_blank" rel="external">Sublime Text 3</a></li>
</ol>
<a id="more"></a>
<h3 id="Hexo:">Hexo:</h3><p>Hexo是一款基于nodejs的轻量博客框架。还支持Markdown编辑。使用以及特性点击上面的Hexo链接查看即可，容易上手。我选择Hexo，主要因为nodejs，最近一直在捣腾nodejs，所以想用nodejs通用前后端，做一些好玩的东西（PHP就没多大新意了）在学习了express+nodejs一段时间后，发现要在短时间内用它制作博客，对于我来说还是比较困难的，所以直接动用了Hexo。</p>
<h3 id="Github_Pages:">Github Pages:</h3><p>这是github免费提供的代码托管服务，好像是有300M的空间，其他的一些参数也都满足个人博客的需求，几乎现在所有IT从业者都有github的账号，怎么使用也就不阐述。不过因为一些“你懂得”的原因，github国内访问比较慢，过段时间会把数据迁移到gitcafe上，看了一些别人的博客，感觉速度很快。</p>
<h3 id="Git:">Git:</h3><p>使用git的话，需要掌握一些简单的命令操作，不过网上教程蛮多的，照猫画虎就行，用着用着就熟了。另外这里是<a href="http://git-scm.com/book/zh/v1" target="_blank" rel="external">Git官方中文教程</a>，有意者可以戳进去看看。</p>
<p>这里需要说明一点的是使用Github for Windows客户端也是可以的，而且其界面也是十分的简洁与方便，可以省去很多敲命令的操作，不过从我个人来讲，git熟练之后，效率更高。</p>
<h3 id="Nodejs:">Nodejs:</h3><p>这里只需要下载安装包，一路戳下去就行，主要是要使用npm工具。</p>
<h3 id="多说:">多说:</h3><p>因为Hexo是用于布置轻量静态博客的工具，所以评论功能需要引入外部js来实现，虽然Hexo内置了Disqus，但国内的话，还是用国内的产品好一点。</p>
<h3 id="Next_Theme:">Next Theme:</h3><p>Next是一款Hexo的主题，点击上面的链接进入其github主页，选择它纯粹是个人喜好啦，在接下来的一段时间里会对这个主题进行一些定制，暂时打算多写几套博客主题来加深自己对html5和css3还有jQuery这些基础前端知识的掌握。</p>
<h3 id="七牛:">七牛:</h3><p>图床用，以后迁移大的静态数据也方便，标准用户免费享用的资源足够个人使用。</p>
<h3 id="Sublime_Text_3:">Sublime Text 3:</h3><p>这个就不用多说了，轻量文本编辑工具，各种强大的插件与快捷操作，多少让人想到了Vim，Geek范十足！</p>
<h2 id="搭建过程">搭建过程</h2><h4 id="1-_建立github_pages">1. 建立github pages</h4><p>创建一个格式为username.github.io的repository即可。</p>
<h4 id="2-_连接github_pages">2. 连接github pages</h4><p>使用git bash shell 创建ssh key，使用该key连接。</p>
<h4 id="3-_安装Hexo">3. 安装Hexo</h4><p>在bash shell下，用npm安装Hexo，安装主题，修改配置文件，重新generate <code>hexo g</code> 然后 <code>hexo s</code>，打开localhost:4000进行测试。</p>
<h4 id="4-_购买域名">4. 购买域名</h4><p>国内域名需要备案，比较麻烦，这里使用的是国外的Godaddy（狗爹），最棒的是可以用支付宝付款。</p>
<h4 id="5-_域名绑定">5. 域名绑定</h4><p>这里使用国内的DNSpod进行DNS解析。在github pages的根目录下，直接创建一个无后缀的文件CNAME，直接编辑它的内容为你购买的域名，不需要前面的协议部分（像http或者https）,这样就完成绑定了</p>
<h4 id="6-_部署">6. 部署</h4><p>在按照自己的想法修改本地文件后，重新生成 <code>hexo g</code>，再执行 <code>hexo d</code> （之前要在配置文件对部署这一项修改好）即可部署到github，再在浏览器地址栏输入购买的域名就可以访问了。</p>
<p>这里需要注意一点的是，每次修改完本地文件后，最好是先执行 <code>hexo clean</code> 命令，然后 <code>hexo g</code> 生成静态文件，再在本地预览 <code>hexo s</code> ，发现符合效果后再进行部署。因为本人遇到过 <code>hexo new postName</code>，实际页面出现两个post的情况，采用上面的方法可以避免出现这个问题。</p>
<h2 id="遇到的问题">遇到的问题</h2><ol>
<li><p>在建立github pages时，要注意这里的username不是昵称，如果要修改username的话，步骤为 <strong>Settings-&gt;Account Settings-&gt;Change username</strong> 。此外网上有些教程后缀为.com，但应该现在的github pages应该都转到了.io，所以使用.io更好。</p>
</li>
<li><p>连接github时，网上虽然有很多教程，但有的根本没用！！！会出现怎么都连不上的情况。下面的参考资料中的方法亲测可用。另外使用github for windows就可以免去这一繁琐的步骤，因为它会自动生成key。</p>
</li>
<li><p>购买域名时，如果没多少钱的话，可以去网上搜这个时间段的Godaddy的优惠码，我注册时，貌似有优惠。不过这里我很想吐槽了，为什么提交时有左右两个按钮，我照着以前的教程貌似点了左边那个，是不是这样就没有优惠了？希望知道的人知会我一下，先谢过了。另外个人网站域名可以选择.com或者.me，网上有人说不要选择.info，因为一些黑历史，该域名被Google惩罚了。用支付宝支付时，一定要注意的是，款项单位不要用人民币（CNY），用默认的美元（USD）就行，不然会出现无法支付的问题。</p>
</li>
<li><p>最开始我是不知道怎么部署的，下面参考资料介绍的配置方法可行。</p>
</li>
<li><p>有的主题中的一些文件会使用google提供的js文件、字体或者样式，还是因为一些“你懂得”的原因，会导致加载很慢，甚至样式出现不了。推荐将其替换为国内的CDN服务，比如百度CDN公共库。</p>
</li>
</ol>
<h2 id="参考资料">参考资料</h2><ol>
<li><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">http://www.jianshu.com/p/05289a4bc8b2</a></li>
<li><a href="http://www.tuicool.com/articles/uE7FJba" target="_blank" rel="external">http://www.tuicool.com/articles/uE7FJba</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直想做些好玩的事了，比如说做个个人网站啥的（虽然做个网站是基础中的基础，没多大技术含量……汗颜），在看到同学捣腾的<a href="http://www.jellybool.com/">作品</a>后，心向往之，但由于本人拖延症已到晚期，五月病时不时还要发作一下，迟迟未开始，在深刻认识到技术需要实践这个道理之后，终于动工啦！用《舰队collection》里面的话来说就是“不要怂，单纵就是干”！</p>
<p>这篇文章主要是对博客搭建过程做个记录，但不会很详细的讲述。以下分为三个方面来做阐述：采用的工具、搭建流程以及遇到的问题。如果这些浅薄的文字能够帮助到遇到同样问题的有缘人，那是我的荣幸。</p>
<h2 id="采用的工具">采用的工具</h2><ol>
<li><a href="http://hexo.io/">Hexo</a></li>
<li><a href="https://github.com/">Github Pages</a></li>
<li><a href="http://msysgit.github.io/">Git</a>或者<a href="https://windows.github.com/">Github for Windows</a></li>
<li><a href="http://nodejs.org/">Node.js</a></li>
<li><a href="http://duoshuo.com/">多说</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next">Next Theme</a></li>
<li><a href="http://www.qiniu.com/">七牛</a></li>
<li><a href="http://www.sublimetext.com/">Sublime Text 3</a></li>
</ol>]]>
    
    </summary>
    
      <category term="Hexo" scheme="https://nekonyan.me/tags/Hexo/"/>
    
  </entry>
  
</feed>